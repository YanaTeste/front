<?php
// $Id: junk.module,v 1.3 2010/04/21 09:40:58 alirasirin Exp $
/**
 * @file
 * Main module file.
 * 
 * Junk module provides functionality to move nodes to Junk before completely deleting. 
 */

/**
 * Implementation of hook_menu().
 */
function junk_menu() {   
  $items['junk/clear'] = array(
    'title' => 'Clear junk confirm',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('junk_clear_junk_confirm'),
    'access arguments' => array('clear junk'),
    'type' => MENU_CALLBACK,
  );  
  $items['junk'] = array(
    'title' => 'Junk',
    'page callback' => 'junk_view_page',
    'access arguments' => array('clear junk'),
  );  
  $items['node/%node/junk'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('junk_node_form_junk_confirm', 1),
    'access callback' => 'junk_can_junk',
    'access arguments' => array(1),
    'weight' => 9,
    'type' => MENU_LOCAL_TASK,
  );
  $items['junk/%node/restore'] = array(
    'title' => 'Restore',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('junk_restore_node_confirm', 1),
    'access callback' => 'junk_can_restore',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
  );
  $items['junk/%node/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('junk_delete_node_confirm', 1),
    'access arguments' => array('clear junk'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );  
  $items['admin/settings/junk'] = array(
    'title' => 'Junk settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('junk_admin_settings'),
    'access arguments' => array('administer junk'),
  );
  return $items;
}

/*
 * Implemetation of hook_form_alter(). Adding special buttons to node form.
 */
function junk_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id && !empty($form['#node']->nid)) {
    unset($form['buttons']['delete']);
     if(junk_is_junked($form['#node'])) {
	        if (junk_can_restore($form['#node'])) {
	      	// Adding 'Restore' button
	      	  $form['buttons']['restore'] = array(
	            '#value'  => l(t('Restore'),'junk/'.$form['#node']->nid.'/restore'),
	            '#weight' => 15 
	          );
	        }
	    }
	    else {
	       if (junk_can_junk($form['#node'])) {
	      	// Adding 'Junk' button
	         $form['buttons']['junk'] = array(
	           '#type'   => 'submit',
	           '#value'  => t('Move to junk'),
	           '#weight' => 15,
	           '#submit' => array('junk_node_form_junk_submit'),
	         );
	       }
	    }	
  }
}

/*
 * Implemetation of hook_menu_alter(). Limiting access to standart deletion page.
 */
function junk_menu_alter(&$items) {
  $items['node/%node/delete']['access callback'] = 'user_access';
  $items['node/%node/delete']['access arguments'] = array('clear junk');
}

/*
 * Confirm deleteing junk form
 */
function junk_clear_junk_confirm($form) {
  $form = array();
  return confirm_form($form,
    t('Are you sure you want to empty junk?'),
	  'junk',
	  t('This action cannot be undone'),
	  t('Clear'),
	  t('Cancel')
  );
}

function junk_clear_junk_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    // Delete the node.
    $result=db_query("SELECT nid FROM {junk_node}");
    while ($node = db_fetch_array($result)) {
      node_delete($node);
    }
    drupal_set_message("Junk cleared", 'status');
  }
  // Go to junk list
  $form_state['redirect'] = 'junk'; 
}


/**
 *  Implementation of hook_perm() for junking nodes
 */
function junk_perm() {
  $perms = array('clear junk', 'junk any content', 'restore any content from junk', 'administer junk');
  $types = node_get_types();
  foreach ($types as $type) {
    $perms[] = 'junk own '.$type->type.' content';
  }
  return $perms;
}

/**
 *  Check if user can junk the node
 */
function junk_can_junk($node, $account = NULL) {
  global $user;

  if (empty($node)) {
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

  if (user_access('administer nodes', $account)) {
    return TRUE;
  }

  if (!user_access('access content', $account)) {
    return FALSE;
  }
   
  if (user_access('junk any content', $account))
  {
    return TRUE;
  }
  
  $name = check_plain($node->type);
  if (user_access('junk own '.$name.' content') && $node->uid == $account->uid) {  
    return TRUE;
  }

  return FALSE;
}

function junk_can_restore($node, $account = NULL) {
  global $user;

   // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }
  
  if (user_access('restore any content from junk')) {
    return TRUE;
  }
  
  if (junk_can_junk($node, $account)) {
    return TRUE;
  }
  
}

/**
 *  Submit handler for junk button
 */
function junk_node_form_junk_submit($form, &$form_state) {
  $destination = '';
  if (isset($_REQUEST['destination'])) {
    $destination = drupal_get_destination();
    unset($_REQUEST['destination']);
  }
  $node = $form['#node'];
  $form_state['redirect'] = array('node/' . $node->nid . '/junk', $destination);
}

/**
 *  Menu callback -- ask for confirmation before junking the node
 */
function junk_node_form_junk_confirm($form, $node) {
  $form = array();
  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  return confirm_form($form,
    t('Are you sure you want to move to junk %title?', array('%title' => $node->title)),
    isset($_GET['destination']) ? $_GET['destination'] : 'node/' . $node->nid,
    t('This action can be undone later.'),
    t('Move to junk'),
    t('Cancel')
  );
}

/**
 * Execute junking action.
 *
 */
function junk_node_form_junk_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $node = node_load($form_state['values']['nid']);
    global $user;
    db_query("INSERT INTO {junk_node} VALUES (%d, %d, %d)", $node->nid, $user->uid, time());
    if (variable_get('junk_unpublish', 1)) {
      node_unpublish_action($node);
      node_save($node);
    }
    if (module_exists('rules')) {
      rules_invoke_event('junk_junk_node', $node, $user);
    }
    drupal_set_message(t("Node moved to junk"), 'status');
  }
  $form_state['redirect'] = '<front>';
}

/*
 * Junk page view 
 */
function junk_view_page() {
  $output = '';
  $header = array(
    array('data' => NULL, 'colspan' => 2),
    array('data' => t('Type'), 'field' => 'n.type'),
    array('data' => t('Title'), 'field' => 'n.title'),
    array('data' => t('Deleted on'), 'field' => 'n.date', 'sort' => 'desc'),
  );
  $count_sql = "SELECT COUNT(nid) FROM {junk_node}";
  $node_sql = "SELECT n.title, n.type, ut.date, n.nid, ut.uid, u.name FROM {node} n, {junk_node} ut, {users} u WHERE ut.nid=n.nid AND ut.uid=u.uid ORDER BY ut.date DESC";
  $result = pager_query($node_sql, 50, 0, $count_sql);
  $nodes = array();
  while ($node = db_fetch_object($result)) {
    $nodes[] = $node;
  }
  if (count($nodes)) {
    $node_types = node_get_types('names');
    $rows = array();
    foreach ($nodes as $node) {
      $row = array(
        l('(' . t('restore') . ')', "junk/$node->nid/restore"),
        l('(' . t('delete') . ')', "junk/$node->nid/delete"),
        $node_types[$node->type],
        l($node->title, "node/$node->nid"),
        t('!date by !username', array(
          '!date' => format_date($node->date, 'small'),
          '!username' => theme('username', $node))),
      );
      $rows[] = $row;
    }
    $output .= theme('table', $header, $rows);
    $output .= theme('pager', NULL, 50, 0);
    $output .= '<p>' . l(t('Empty junk'), "junk/clear") . '</p>';
  }
  else {
    $output .= '<p>' . t('The junk is empty') . '</p>';
  }
  return $output;
}

/**
 * Restore node confirmation form.
 */
function junk_restore_node_confirm(&$form_state, $node) {
  $form = array();
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  return confirm_form($form,
   t('Are you sure you want to restore %title?', array('%title' => $node->title)),
   isset($_GET['destination']) ? $_GET['destination'] : 'junk',
   '',
   t('Restore'), t('Cancel'));
}

/**
 * Restore node confirmation form submit handler.
 */
function junk_restore_node_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $node = node_load($form_state['values']['nid']);
    // Save node as a published again.
    db_query("DELETE FROM {junk_node} WHERE nid=%d", $node->nid);
    if (variable_get('junk_unpublish', 1)) {
      node_publish_action($node);
      node_save($node);
    }
    if (module_exists('rules')) {
      global $user;
      rules_invoke_event('junk_unjunk_node', $node, $user);
    }
    drupal_set_message("Node restored from junk", 'status');
    $form_state['redirect'] = 'junk';
  }
  else {
    // Go to junk list
    $form_state['redirect'] = 'junk'; 
  }
}

/**
 * Permanently delete node confirmation form.
 */
function junk_delete_node_confirm(&$form_state, $node) {
  $form = array();
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  return confirm_form($form,
    t('Are you sure you want to permanently delete %title?', array('%title' => $node->title)),
    isset($_GET['destination']) ? $_GET['destination'] : 'junk',
    t('This action cannot be undone.'),
    t('Delete'), t('Cancel'));
}

/**
 * Permanently delete node confirmation form submit handler.
 */
function junk_delete_node_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    // Delete the node.
    node_delete($form_state['values']['nid']);
    drupal_set_message(t("Node was completly deleted"), 'status');
  }
  // Go to junk list
  $form_state['redirect'] = 'junk'; 
}

/*
 * Check if node is junked
 */
function junk_is_junked($node) {
  if (is_object($node)) {
    $nid = $node->nid;
  }
  elseif (is_numeric($node)) {
    $nid = $node;
  }
  else return FALSE;
  $result = db_query("SELECT nid FROM {junk_node} WHERE nid=%d", $nid);
  $exists = db_fetch_array($result);
  if (!empty($exists)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_ctools_plugin_api()
 *
 * Needed so that our other hooks are picked up.
 */
function junk_ctools_plugin_api($module, $api) {
  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_dierctory() to let the system know
 * we implement task_handler.
 */
function junk_ctools_plugin_directory($module, $plugin) {
  if ($module == 'page_manager' || $module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implementation of hook_default_page_manager_handlers()
 */
function junk_default_page_manager_handlers() {
  // Node view handler settings
  $handler_view = new stdClass;
  $handler_view->disabled = FALSE; 
  $handler_view->api_version = 1;
  $handler_view->name = 'node_view_junk';
  $handler_view->task = 'node_view';
  $handler_view->subtask = '';
  $handler_view->handler = 'junk_node_view';
  $handler_view->weight = -200;
  $handler_view->conf = array(
    'autogenerate_title' => FALSE,
    'title' => 'Junk Node View',
    'contexts' => array(),
    'relationships' => array(
      '0' => array(
        'context' => 'argument_nid_1',
        'name' => 'nid',
        'id' => 1,
        'identifier' => 'Junked node',
        'keyword' => 'node',
      ),
    ),
  );
  $handlers[$handler_view->name] = $handler_view; 
  // Node edit handler settings
  $handler_edit = new stdClass;
  $handler_edit->disabled = FALSE; 
  $handler_edit->api_version = 1;
  $handler_edit->name = 'node_edit_junk';
  $handler_edit->task = 'node_edit';
  $handler_edit->subtask = '';
  $handler_edit->handler = 'junk_node_edit';
  $handler_edit->weight = -200;
  $handler_edit->conf = array(
    'autogenerate_title' => FALSE,
    'title' => 'Junk Node Edit',
    'contexts' => array(),
    'relationships' => array(
      '0' => array(
        'context' => 'argument_nid_1',
        'name' => 'nid',
        'id' => 1,
        'identifier' => 'Junked node',
        'keyword' => 'node',
      ),
    ),
  );
  $handlers[$handler_edit->name] = $handler_edit; 
  return $handlers;
}

/*
 * Implemetation of hook_nodeapi
 */
function junk_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'delete': //delete junked node from junked nodes list
      db_query("DELETE FROM {junk_node} WHERE nid=%d", $node->nid);
      break;
  }
}

/**
 * Implementation of hook_db_rewrite_sql().
 */
function junk_db_rewrite_sql($query, $primary_table, $primary_field, $args) {
  switch ($primary_field) {
    case 'nid': // a node query
      $hide_in_listings = variable_get('junk_hide_in_listings', 1);
      $hide_in_views = variable_get('junk_hide_in_views', 1);
      if ((!isset($args['view']) && $hide_in_listings) || (isset($args['view']) && $hide_in_views)) {
        return array(
          'join'  => 'LEFT JOIN {junk_node} jn ON jn.nid = ' . $primary_table . '.nid',
          'where' => 'jn.date IS NULL'
        );
      }
      break;
  }
}

/**
 * Admin settings form
 */
function junk_admin_settings($form_state) {
  $form = array();
  $form["junk_lifetime"] = array(
    '#type' => 'select', 
	'#title' => t('Lifetime of nodes in junk (in days)'), 
	'#default_value' => variable_get('junk_lifetime', 0),
	'#weight' => -10,
	'#options' => array(
	  0 => t('unlimited'), 
	  1 => 1, 
	  2 => 2,
	  3 => 3,
	  4 => 4,
	  5 => 5,
	  6 => 6,
	  7 => 7,
	  14 => 14,
	  30 => 30,
	),
	'#description' => t('Nodes in junk are automatically deleted when their lifetime exceeds this setting. Works if Cron is enabled.'),
	);
  $form["junk_hide_in_listings"] = array(
    '#type' => 'checkbox',
	'#default_value' => variable_get('junk_hide_in_listings', 1),
	'#title' => t('Hide junked nodes in node listings (not including Views)')
  );
  $form["junk_hide_in_views"] = array(
	'#type' => 'checkbox',
	'#default_value' => variable_get('junk_hide_in_views', 1),
	'#title' => t('Hide junked nodes in Views')
  );
  $form["junk_unpublish"] = array(
	'#type' => 'checkbox',
	'#default_value' => variable_get('junk_unpublish', 1),
	'#title' => t('Unpublish junked nodes')
  );
  $form["junk_show_contents"] = array(
	'#type' => 'checkbox',
	'#default_value' => variable_get('junk_show_contents', 1),
	'#title' => t('Show contents of junked nodes to administers')
  );
  return system_settings_form($form);
}

/*
 * Implementation of hook_cron() - "garbage collector"
 */
function junk_cron() {
  $lifetime = variable_get('junk_lifetime', 0);
  if ($lifetime > 0) {
    $old=time()-$lifetime*86400;
		$result=db_query('SELECT jn.nid FROM {junk_node} jn WHERE jn.date<%d', $old);
		while ($row=db_fetch_object($result)) {
			//node_delete() can't be used here because it checkes node_access() and 
			//cron is run under user 0 who doesn't have access to delete nodes usually
			
      $node = node_load($row->nid, NULL, TRUE);
      
      db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);
      db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);

      // Call the node-specific callback (if any):
      node_invoke($node, 'delete');
      node_invoke_nodeapi($node, 'delete');

      // Clear the page and block caches.
      cache_clear_all();

      // Remove this node from the search index if needed.
      if (function_exists('search_wipe')) {
        search_wipe($node->nid, 'node');
      }
      watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));
  
		}
  }
}

/*
 * Implementation of hook_views_api()
 */
function junk_views_api() {
  return array(
    'api' => '2.0',
  );
}

/**
 * Implementation of hook_rules_event_info().
 */
function junk_rules_event_info() {
  return array(
    'junk_junk_node' => array(
      'label' => t('Node has been moved to junk'),
      'module' => 'Junk',
      'arguments' => array(
        'junk_node' => array('type' => 'node', 'label' => t('Junked node')),
        'junk_user' => array('type' => 'user', 'label' => t('Acting user')),
      ),
    ),
    'junk_unjunk_node' => array(
      'label' => t('Node has been restored from junk'),
      'module' => 'Junk',
      'arguments' => array(
        'junk_node' => array('type' => 'node', 'label' => t('Restored node')),
        'junk_user' => array('type' => 'user', 'label' => t('Acting user')),
      ),
    ),
  );
}

/**
 * Implementation of hook_og_subscriptions_alter(). This hook invoke may be injected in OG module function  
 * og_get_subscriptions() to alter user OG subscriptions for junked nodes (this is needed because db_sql_rewrite doesn't 
 * deal with loading user subscriptions in og_get_subscriptions())
 * @param $subscriptions - keyed array of subscriptions
 */
function junk_og_subscriptions_alter(&$subscriptions)
{
	foreach ($subscriptions as $key => $value)
	{
		if (junk_is_junked($key))
			unset($subscriptions[$key]);
	}
}


